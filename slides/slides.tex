\documentclass[10pt, xetex, hyperref={pdfpagelabels=false,breaklinks}]{beamer}

% --------------------------------------------------------------------------
% Packages
% --------------------------------------------------------------------------
\usepackage[english]{babel}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{bussproofs}
\EnableBpAbbreviations
\def\extraVskip{3pt}

\usepackage{fancyvrb}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{lmodern}

\usepackage{url}


% --------------------------------------------------------------------------
% Tikz Configuration
% --------------------------------------------------------------------------
\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{calc}
\usepackage{rotating}

% --------------------------------------------------------------------------
% My palette.
% --------------------------------------------------------------------------
\definecolor{aliceblue}{rgb}{0.94, 0.97, 1.0}
\definecolor{energy}{RGB}{49,247,250}
\definecolor{delicate}{RGB}{67,179,223}
\definecolor{faded}{RGB}{76,117,195}
\definecolor{blu}{RGB}{1,0,102}
\definecolor{plum}{RGB}{87,78,164}
\definecolor{petunias}{RGB}{109,80,139}
\definecolor{letour}{RGB}{101,41,105}
\definecolor{carmine}{rgb}{0.59, 0.0, 0.09}
% --------------------------------------------------------------------------

% --------------------------------------------------------------------------
% Beamer configuration.
% --------------------------------------------------------------------------
\usetheme{default}
\usecolortheme{default}
\usefonttheme{serif}

\beamertemplatenavigationsymbolsempty
\setbeamertemplate{navigation symbols}{}
\hypersetup{pdfpagemode=UseNone}

% footer.
\setbeamercolor{headFoot}{fg=white, bg=blu}
\setbeamertemplate{footline}{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}
    [wd=.8\paperwidth,ht=2.3ex,dp=1ex,left]{headFoot}%
    \hspace*{2ex}\textbf\insertshorttitle\hspace*{2mm}|
    \hspace*{2mm}\textbf\insertshortauthor
  \end{beamercolorbox}%
  \begin{beamercolorbox}
    [wd=.2\paperwidth,ht=2.3ex,dp=1ex,right]{headFoot}%
    \insertframenumber{}/\inserttotalframenumber\hspace*{2ex}
  \end{beamercolorbox}}%
  \vskip 0pt%
}

\setbeamerfont{frametitle}{size=\small,series=\bfseries}
\setbeamercolor{frametitle}{fg=white,bg=blu}

\setbeamerfont{framesubtitle}{size=\normalfont\scriptsize}
\setbeamercolor{framesubtitle}{fg=white, bg=blu}

\setbeamercolor{background canvas}{bg=white}
\setbeamercolor{normal text}{fg=black}

% \setbeamercolor{institute}{fg=blu}
\setbeamercolor{title}{fg=blu}
\setbeamercolor{bibliography item}{fg=blu}
% \setbeamercolor{subtitle}{fg=blu}

% \setbeamercolor{titlelike}{fg=blu}
\setbeamerfont{footnote}{size=\tiny}
\setbeamercolor{footnote}{fg=gray}
\setbeamercolor{block title}{bg=white,fg=blu}
% \setbeamercolor{block body}{bg=aliceblue}
\setbeamercolor{item}{fg=blu} % color of bullets
\setbeamercolor{subitem}{fg=blu}
% \setbeamercolor{itemize/enumerate subbody}{fg=blu}
% \setbeamertemplate{itemize subitem}{{\textendash}}
% \setbeamerfont{itemize/enumerate subbody}{size=\footnotesize}
% \setbeamerfont{itemize/enumerate subitem}{size=\footnotesize}

% --------------------------------------------------------------------------
% Fonts
% --------------------------------------------------------------------------
\usefonttheme{professionalfonts}
\usefonttheme{serif}
\usepackage{fontspec}
\usepackage{mathtools}
\usepackage{unicode-math}

\setmonofont[ExternalLocation=fonts/
, BoldFont=DejaVuSansMono-Bold.ttf
, BoldItalicFont=DejaVuSansMono-BoldOblique.ttf
, ItalicFont=DejaVuSansMono-Oblique.ttf
]{DejaVuSansMono.ttf}

\setmathfont[ExternalLocation=fonts/
  , Colour=blu
  ]{DejaVuMathTeXGyre.ttf}
\newfontfamily\mathfont{fonts/DejaVuMathTeXGyre.ttf}

\setmainfont[ExternalLocation=fonts/
  , BoldFont=SourceSansPro-Semibold.otf
  , BoldItalicFont=SourceSansPro-SemiboldIt.otf
  , ItalicFont=SourceSansPro-It.otf
  ]{SourceSansPro-Regular.otf}

% --------------------------------------------------------------------------
% Agda Source code
% --------------------------------------------------------------------------

\usepackage{minted}
\setminted[cagda]{
  bgcolor   = aliceblue
, fontsize  = \footnotesize
, frame     = none
% , framerule = 0.4pt
% , framesep  = 0pt
, style     = cagda
}

% --------------------------------------------------------------------------
% References
% --------------------------------------------------------------------------

\usepackage[autostyle]{csquotes}
\usepackage[
    backend=biber
  , doi=false
  , eprint=false
  , isbn=false
  , natbib=true
  , sortlocale=en_US
  , style=authoryear-icomp
  , url=true
  , block=ragged
]{biblatex}
\addbibresource{ref.bib}
\renewcommand*{\nameyeardelim}{\addcomma\addspace}
\usepackage{silence}
\WarningFilter{biblatex}{Patching footnotes failed}
\WarningFilter{hyperref}{Token not allowed in a PDF string}

% --------------------------------------------------------------------------
% Title and Author
% --------------------------------------------------------------------------

\title[The Simply Typed Lambda Calculus]{The Simply Typed Lambda Calculus}

\subtitle{(In \texttt{Agda})}
\date{\footnotesize 1th June 2017}
\author[Jonathan Prieto-Cubides]{Jonathan Prieto-Cubides}
\institute{
Master in Applied Mathematics\\
Logic and Computation Group\\
Universidad EAFIT\\
Medell\'in, Colombia}
% --------------------------------------------------------------------------

\newsavebox\agdapragma

\begin{document}
\setcounter{page}{1}

\begin{frame}[plain]
\titlepage
  \begin{tikzpicture}[overlay, remember picture]
   \tikzset{shift={(current page.center)}}
    \node[xshift=0cm,yshift=-3.2cm] (eafit)
      {\includegraphics[width=0.2\textwidth]{figures/eafit}};
  \end{tikzpicture}
\end{frame}


\begin{frame}{Contents}
\tableofcontents
\end{frame}

\begin{frame}{About}
\begin{itemize}
\item The Agda source code of this talk is available in the repository
{\color{plum}
\begin{center}
\href{https://github.com/jonaprieto/stlctalk}{https://github.com/jonaprieto/stlctalk}.
\end{center}
}
We present a refactor of the implementation by \citep{cactus} for the simple lambda calculus,
specifically in the Scopecheck and Typecheck module.
\item Tested with Agda v$2.5.2$ and Agda Standard Library v$0.13$
\end{itemize}
\end{frame}

\section{Lambda Calculus}
\begin{frame}[fragile]{Lambda Calculus}
\begin{definition}
\begin{itemize}
\item The set of $\lambda$-terms denoted by $\Lambda$ is built up
from a set of variables $V$ using application and (function) abstraction
\begin{align*}
x\in V                &\Rightarrow x\in \Lambda, \\
M\in \Lambda, x\in V  &\Rightarrow (\lambda x. M) \in \Lambda,\\
M, N\in \Lambda       &\Rightarrow (MN) \in \Lambda.
\end{align*}
\item A simple syntax definition for lambda terms
\vskip 1.5mm
\begin{minted}{cagda}
Name : Set
Name = String

data Expr : Set where
  var : Name ‚Üí Expr
  lam : Name ‚Üí Expr ‚Üí Expr
  _‚àô_ : Expr ‚Üí Expr ‚Üí Expr
\end{minted}
\end{itemize}
\end{definition}
\end{frame}

\section{Typed Lambda Calculus}
\begin{frame}{Lambda Curry System}
\begin{itemize}
\item The set of types is noted with $ùïã =\text{ Type}(\lambda\rightarrow)$.
$$ùïã = ùïç\, |\, ùîπ\, |\, ùïã ‚Ü£ ùïã,$$
where $ùïç = \{Œ±‚ÇÅ,Œ±‚ÇÇ, \cdots \}$ be a set of type variables,
$ùîπ$ stands for a collection of type constants for basic types
like \texttt{Nat} or \texttt{Bool}
\item A \emph{statement} is of the form $M : œÉ$ with $M ‚àà Œõ$ and $œÉ ‚àà ùïã$
\item \emph{Derivation} inference rules
\vskip 1mm
\begin{columns}
  \begin{column}{0.5\textwidth}
    \begin{prooftree}
    \AxiomC{$M : œÉ ‚Ü£ œÑ$}
    \AxiomC{$N : œÉ$}
    \BinaryInfC{$MN : œÑ$}
    \end{prooftree}
  \end{column}
  \begin{column}{0.5\textwidth}
    \begin{prooftree}
    \AxiomC{$[x : \sigma]^{(1)}$}
    \UnaryInfC{$\vdots$}
    \UnaryInfC{$M : \tau$}
    \RightLabel{\scriptsize (1)}
    \UnaryInfC{$Œªx.M : œÉ ‚Ü£ \tau$}
    \end{prooftree}
  \end{column}
\end{columns}
\vskip 1mm
\item A statement $M : \sigma$ is derivable form a \textit{basis} $Œì$ denoted
by $Œì ‚ä¢ M : œÉ$ where basis stands for be a set of statements with only distinct
(term) variables as subjects
\end{itemize}
\end{frame}

\section{Syntax Definitions}
\begin{frame}[fragile]{Syntax defintion based on ~\citep{cactus}, and \citep{nad}}
\begin{itemize}
  \item Typing syntax: $ùïã = ùïç\, |\, ùîπ\, |\, ùïã ‚Ü£ ùïã$,
  \vskip 1.5mm
\begin{minted}{cagda}
module Typing (U : Set) where

data Type : Set where
  base : U    ‚Üí Type
  _‚Ü£_  : Type ‚Üí Type ‚Üí Type
\end{minted}

\item A syntax definition including type annotations
\vskip 1.5mm
\begin{minted}{cagda}
module Syntax (Type : Set) where

open import Data.String

Name : Set
Name = String

data Formal : Set where
  _‚à∂_ : Name ‚Üí Type ‚Üí Formal

data Expr : Set where
  var : Name   ‚Üí Expr
  lam : Formal ‚Üí Expr ‚Üí Expr
  _‚àô_ : Expr   ‚Üí Expr ‚Üí Expr
\end{minted}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Examples}
\begin{minted}{cagda}
open import Syntax Type

postulate A : Type

x = var "x"
y = var "y"
z = var "z"

-- Combinators.
-- I, K, S : Expr

I = lam ("x" ‚à∂ A) x                  -- Œªx.x, x : A
K = lam ("x" ‚à∂ A) (lam ("y" ‚à∂ A) x)  -- Œªxy.x, x,y : A
S =
  lam ("x" ‚à∂ A)
    (lam ("y" ‚à∂ A)
      (lam ("z" ‚à∂ A)
        ((x ‚àô z) ‚àô (y ‚àô z))))        -- Œªxyz.xz(yz), x,y,z : A
\end{minted}
\end{frame}

\section{Decibility of Type Assignment}
\begin{frame}{Decibility of Type Assignment~\citep{barendregt2013lambda}}

\begin{tabular}{ll}
{\color{blu} \textbf{Problem}} & {\color{blu} \textbf{Question}} \\
{\color{blu} Typability}       & Given $M$ does exists a $œÉ$ such that $Œì ‚ä¢ M : œÉ$? \\
{\color{blu} Type-checking}    & Given $M$ and $œÑ$, can we have $Œì ‚ä¢ M : œÑ$?  \\
{\color{blu} Inhabitation}     & Given $œÑ$, does exists an $M$ such that $Œì ‚ä¢ M : œÉ$?\\
\end{tabular}

\begin{theorem}%[Typability]
\begin{itemize}
\item It is decidable whether a term is typable in $\lambda\rightarrow$.
\item If a term $M$ is typable in $\lambda\rightarrow$, then M has a principal type scheme, i.e.
a type $œÉ$ such that every possible type for $M$ is a subsitution instance of $œÉ$.
Moreover $œÉ$ is computable from $M$.
\end{itemize}
\end{theorem}

\begin{theorem}%[Type-checking]
Type checking for $\lambda\rightarrow$ is decidable.
\end{theorem}

\end{frame}

\section{Well-Scoped Lambda Expressions}
\begin{frame}[fragile]{De Bruijn Index}
\begin{itemize}
\item The indexes are natural numbers that represent the occurrences of the variable in a Œª-term
$$  Œªx. Œªy. x ‚áù  Œª Œª 2$$
\item The natural number denotes the number of binders that are in scope between that occurrence and its corresponding binder
$$Œªx. Œªy. Œªz. x z (y z)  ‚áù Œª Œª Œª 3 1 (2 1)$$
\item Check for $Œ±$-equivalence is the same as that for syntactic equality
\item A syntax definition using De Bruijn indexes\\[3mm]
\begin{minted}{cagda}
data Expr (n : ‚Ñï) : Set where
  var : Fin n  ‚Üí Expr n
  lam : Type   ‚Üí Expr (suc n) ‚Üí Expr n
  _‚àô_ : Expr n ‚Üí Expr n       ‚Üí Expr n
\end{minted}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{\texttt{module Bound (Type : Set) where}}
% Well-scoped Expresions with respect to a variable Binder.
\begin{minted}{cagda}
Binder : ‚Ñï ‚Üí Set
Binder = Vec Name

data _‚ä¢_‚áù_ : ‚àÄ {n} ‚Üí Binder n ‚Üí S.Expr ‚Üí Expr n ‚Üí Set where

  var-zero : ‚àÄ {n x} {Œì : Binder n}
           ‚Üí Œì , x ‚ä¢ var x ‚áù var (# 0)

  var-suc  : ‚àÄ {n x y k} {Œì : Binder n} {p : False (x ‚âü y)}
           ‚Üí Œì ‚ä¢ var x ‚áù var k
           ‚Üí Œì , y ‚ä¢ var x ‚áù var (suc k)

  lam      : ‚àÄ {n x œÑ t t‚Ä≤} {Œì : Binder n}
           ‚Üí Œì , x ‚ä¢ t ‚áù t‚Ä≤
           ‚Üí Œì ‚ä¢ lam (x ‚à∂ œÑ) t ‚áù lam œÑ t‚Ä≤

  _‚àô_      : ‚àÄ {n t‚ÇÅ t‚ÇÅ‚Ä≤ t‚ÇÇ t‚ÇÇ‚Ä≤} {Œì : Binder n}
           ‚Üí Œì ‚ä¢ t‚ÇÅ ‚áù t‚ÇÅ‚Ä≤
           ‚Üí Œì ‚ä¢ t‚ÇÇ ‚áù t‚ÇÇ‚Ä≤
           ‚Üí Œì ‚ä¢ t‚ÇÅ ‚àô t‚ÇÇ ‚áù t‚ÇÅ‚Ä≤ ‚àô t‚ÇÇ‚Ä≤
\end{minted}
\end{frame}

\begin{frame}[fragile]{Examples}
\begin{minted}{cagda}
‚àÖ : Binder 0
‚àÖ = []

Œì : Binder 2
Œì = "x" ‚à∑ "y" ‚à∑ []

e1 : "x" ‚à∑ "y" ‚à∑ [] ‚ä¢ var "x" ‚áù var (# 0)
e1 = var-zero

I : [] ‚ä¢ lam ("x" ‚à∂ A) (var "x")
       ‚áù lam A (var (# 0))
I = lam var-zero

K : [] ‚ä¢ lam ("x" ‚à∂ A) (lam ("y" ‚à∂ A) (var "x"))
       ‚áù lam A (lam A (var (# 1)))
K = lam (lam (var-suc var-zero))

K‚ÇÇ : [] ‚ä¢ lam ("x" ‚à∂ A) (lam ("y" ‚à∂ A) (var "y"))
        ‚áù lam A (lam A (var (# 0)))
K‚ÇÇ = lam (lam var-zero)

P : Œì ‚ä¢ lam ("x" ‚à∂ A) (lam ("y" ‚à∂ A) (lam ("z" ‚à∂ A) (var "x")))
      ‚áù lam A (lam A (lam A (var (# 2))))
P = {!!}   -- complete!!
\end{minted}
\end{frame}

\begin{frame}[fragile]{\texttt{module Scopecheck (Type : Set) where}}
\begin{minted}{cagda}
name-dec : ‚àÄ {n} {Œì : Binder n} {x y : Name} {t : Expr (suc n)}
         ‚Üí Œì , y ‚ä¢ var x ‚áù t
         ‚Üí x ‚â° y ‚äé ‚àÉ[ t‚Ä≤ ] (Œì ‚ä¢ var x ‚áù t‚Ä≤)

‚ä¢subst : ‚àÄ {n} {x y} {Œì : Binder n} {t}
       ‚Üí x ‚â° y
       ‚Üí Œì , x ‚ä¢ var x ‚áù t
       ‚Üí Œì , y ‚ä¢ var x ‚áù t

find-name : ‚àÄ {n}
          ‚Üí (Œì : Binder n)
          ‚Üí (x : Name)
          ‚Üí Dec (‚àÉ[ t ] (Œì ‚ä¢ var x ‚áù t))

check : ‚àÄ {n}
      ‚Üí (Œì : Binder n)
      ‚Üí (t : S.Expr)
      ‚Üí Dec (‚àÉ[ t‚Ä≤ ] (Œì ‚ä¢ t ‚áù t‚Ä≤))

scope : (t : S.Expr) ‚Üí {p : True (check [] t)} ‚Üí Expr 0
scope t {p} = proj‚ÇÅ (toWitness p)
\end{minted}
\end{frame}

\begin{frame}[fragile]{Examples}
\begin{minted}{cagda}
postulate A : Type

I‚ÇÅ : S.Expr
I‚ÇÅ = S.lam ("x" ‚à∂ A) (S.var "x")

open import Data.Unit

I = scope I‚ÇÅ {p = ‚ä§.tt}  -- Use C-C-C-n and check for I.

x, y, z : S.Expr
x = var "x"
y = var "y"
z = var "z"

S‚ÇÅ =
  lam ("x" ‚à∂ A)
    (lam ("y" ‚à∂ A)
      (lam ("z" ‚à∂ A)
        ((x ‚àô z) ‚àô (y ‚àô z))))

S : Expr 0
S = scope S‚ÇÅ {p = ‚ä§.tt}  -- Use C-C-C-n and check for S.
\end{minted}
\end{frame}


\begin{frame}{Typing Rules}
\begin{itemize}
\item Introduction\\
\begin{prooftree}
\AxiomC{$Œì(t) = \tau$}
\UnaryInfC{$Œì ‚ä¢ t : \tau$}
\end{prooftree}\hfill

\item Abstraction\\
\begin{prooftree}
\AxiomC{$Œì , œÑ ‚ä¢ t : œÉ$}
\UnaryInfC{$Œì ‚ä¢ Œª\ œÑ\ t ‚à∂ œÑ ‚Ü£ \sigma$}
\end{prooftree}\hfill

\item Application
\begin{prooftree}
\AxiomC{$Œì ‚ä¢ t‚ÇÅ : œÑ ‚Ü£ œÉ$}
\AxiomC{$Œì ‚ä¢ t‚ÇÇ : œÑ$}
\BinaryInfC{$Œì ‚ä¢ t‚ÇÅ ‚àô t‚ÇÇ ‚à∂ œÉ$}
\end{prooftree}\hfill
\end{itemize}

\end{frame}

\section{Typability and Type-checking}
\begin{frame}[fragile]{\texttt{module Typing (U : Set) where}}
\begin{minted}{cagda}
open import Bound Type hiding (_,_)

Ctxt : ‚Ñï ‚Üí Set
Ctxt = Vec Type

_,_ : ‚àÄ {n} ‚Üí Ctxt n ‚Üí Type ‚Üí Ctxt (suc n)
Œì , x = x ‚à∑ Œì

data _‚ä¢_‚à∂_ : ‚àÄ {n} ‚Üí Ctxt n ‚Üí Expr n ‚Üí Type ‚Üí Set where

  tVar : ‚àÄ {n Œì} {x : Fin n}
       ‚Üí Œì ‚ä¢ var x ‚à∂ lookup x Œì

  tLam : ‚àÄ {n} {Œì : Ctxt n} {t} {œÑ œÉ}
       ‚Üí Œì , œÑ ‚ä¢ t ‚à∂ œÉ
       ‚Üí Œì ‚ä¢ lam œÑ t ‚à∂ œÑ ‚Ü£ œÉ

  _‚àô_  : ‚àÄ {n} {Œì : Ctxt n} {t‚ÇÅ t‚ÇÇ} {œÑ œÉ}
       ‚Üí Œì ‚ä¢ t‚ÇÅ ‚à∂ œÑ ‚Ü£ œÉ
       ‚Üí Œì ‚ä¢ t‚ÇÇ ‚à∂ œÑ
       ‚Üí Œì ‚ä¢ t‚ÇÅ ‚àô t‚ÇÇ ‚à∂ œÉ
\end{minted}
\end{frame}

\begin{frame}[fragile]{Examples}
\begin{minted}{cagda}
postulate
  Bool : Type

ex : [] , Bool ‚ä¢ var (# 0) ‚à∂ Bool
ex = tVar

ex2 : [] ‚ä¢ lam Bool (var (# 0)) ‚à∂ Bool ‚Ü£ Bool
ex2 = tLam tVar

postulate
  Word : Type
  Num  : Type

K : [] ‚ä¢ lam Word (lam Num (var (# 1))) ‚à∂ Word ‚Ü£ Num ‚Ü£ Word
K = tLam (tLam tVar)
\end{minted}
\end{frame}


\begin{frame}[fragile]{Equality Between Types}
\begin{minted}{cagda}
_T‚âü_ : (œÑ œÑ‚Ä≤ : Type) ‚Üí Dec (œÑ ‚â° œÑ‚Ä≤)
base A T‚âü base B with A ‚âü B
... | yes A‚â°B = yes (cong base A‚â°B)
... | no  A‚â¢B = no (A‚â¢B ‚àò helper)
  where
    helper : base A ‚â° base B ‚Üí A ‚â° B
    helper refl = refl
base A T‚âü (_ ‚Ü£ _) = no (Œª ())

(œÑ‚ÇÅ ‚Ü£ œÑ‚ÇÇ) T‚âü base B = no (Œª ())
(œÑ‚ÇÅ ‚Ü£ œÑ‚ÇÇ) T‚âü (œÑ‚ÇÅ‚Ä≤ ‚Ü£ œÑ‚ÇÇ‚Ä≤) with œÑ‚ÇÅ T‚âü œÑ‚ÇÅ‚Ä≤
... | no  œÑ‚ÇÅ‚â¢œÑ‚ÇÅ‚Ä≤ = no (œÑ‚ÇÅ‚â¢œÑ‚ÇÅ‚Ä≤ ‚àò helper)
  where
    helper :  œÑ‚ÇÅ ‚Ü£ œÑ‚ÇÇ ‚â° œÑ‚ÇÅ‚Ä≤ ‚Ü£ œÑ‚ÇÇ‚Ä≤ ‚Üí œÑ‚ÇÅ ‚â° œÑ‚ÇÅ‚Ä≤
    helper refl = refl
... | yes œÑ‚ÇÅ‚â°œÑ‚ÇÅ‚Ä≤
  with œÑ‚ÇÇ T‚âü œÑ‚ÇÇ‚Ä≤
...  | yes œÑ‚ÇÇ‚â°œÑ‚ÇÇ‚Ä≤ = yes (cong‚ÇÇ _‚Ü£_ œÑ‚ÇÅ‚â°œÑ‚ÇÅ‚Ä≤ œÑ‚ÇÇ‚â°œÑ‚ÇÇ‚Ä≤)
...  | no  œÑ‚ÇÇ‚â¢œÑ‚ÇÇ‚Ä≤ = no (œÑ‚ÇÇ‚â¢œÑ‚ÇÇ‚Ä≤ ‚àò helper)
  where
    helper : œÑ‚ÇÅ ‚Ü£ œÑ‚ÇÇ ‚â° œÑ‚ÇÅ‚Ä≤ ‚Ü£ œÑ‚ÇÇ‚Ä≤ ‚Üí œÑ‚ÇÇ ‚â° œÑ‚ÇÇ‚Ä≤
    helper refl = refl
\end{minted}
\end{frame}
\begin{frame}[fragile]{An Example of an Useful Theorem}
\begin{minted}{cagda}
-- Auxiliar Helper.
‚ä¢-inj : ‚àÄ {n Œì} {t : Expr n} ‚Üí ‚àÄ {œÑ œÉ}
      ‚Üí Œì ‚ä¢ t ‚à∂ œÑ
      ‚Üí Œì ‚ä¢ t ‚à∂ œÉ
      ‚Üí œÑ ‚â° œÉ

-- Var case.
‚ä¢-inj tVar tVar = refl

-- Abstraction case.
‚ä¢-inj {t = lam œÑ t} (tLam Œì,œÑ‚ä¢t:œÑ‚Ä≤) (tLam Œì,œÑ‚ä¢t:œÑ‚Ä≥)
  = cong (_‚Ü£_ œÑ) (‚ä¢-inj Œì,œÑ‚ä¢t:œÑ‚Ä≤ Œì,œÑ‚ä¢t:œÑ‚Ä≥)

-- Application case.
‚ä¢-inj (Œì‚ä¢t‚ÇÅ:œÑ‚Ü£œÑ‚ÇÇ ‚àô Œì‚ä¢t‚ÇÇ:œÑ) (Œì‚ä¢t‚ÇÅ:œÑ‚ÇÅ‚Ü£œÉ ‚àô Œì‚ä¢t‚ÇÇ:œÑ‚ÇÅ)
  = helper (‚ä¢-inj Œì‚ä¢t‚ÇÅ:œÑ‚Ü£œÑ‚ÇÇ Œì‚ä¢t‚ÇÅ:œÑ‚ÇÅ‚Ü£œÉ)
  where
    helper : ‚àÄ {œÑ œÑ‚ÇÇ œÑ‚ÇÅ œÉ} ‚Üí (œÑ ‚Ü£ œÑ‚ÇÇ ‚â° œÑ‚ÇÅ ‚Ü£ œÉ) ‚Üí œÑ‚ÇÇ ‚â° œÉ
    helper refl = refl
\end{minted}
\end{frame}

\begin{frame}[fragile]{Typability I}
\begin{minted}{cagda}
infer : ‚àÄ {n} Œì (t : Expr n) ‚Üí Dec (‚àÉ[ œÑ ] (Œì ‚ä¢ t ‚à∂ œÑ))

-- Var case.
infer Œì (var x) = yes (lookup x Œì -and- tVar)

-- Abstraction case.
infer Œì (lam œÑ t) with infer (œÑ ‚à∑ Œì) t
... | yes (œÉ -and- Œì,œÑ‚ä¢t:œÉ) = yes (œÑ ‚Ü£ œÉ -and- tLam Œì,œÑ‚ä¢t:œÉ)
... | no  Œì,œÑ‚ä¨t:œÉ = no helper
  where
    helper : ‚àÑ[ œÑ‚Ä≤ ] (Œì ‚ä¢ lam œÑ t ‚à∂ œÑ‚Ä≤)
    helper (base A -and- ())
    helper (.œÑ ‚Ü£ œÉ -and- tLam Œì,œÑ‚ä¢t:œÉ)
      = Œì,œÑ‚ä¨t:œÉ (œÉ -and- Œì,œÑ‚ä¢t:œÉ)
\end{minted}
\end{frame}

\begin{frame}[fragile]{Typability II}
\begin{minted}{cagda}
-- Application case part I.
infer Œì (t‚ÇÅ ‚àô t‚ÇÇ) with infer Œì t‚ÇÅ | infer Œì t‚ÇÇ
... | no  ‚àÑœÑ‚ü®Œì‚ä¢t‚ÇÅ:œÑ‚ü© | _ = no helper
    where
      helper : ‚àÑ[ œÉ ] (Œì ‚ä¢ t‚ÇÅ ‚àô t‚ÇÇ ‚à∂ œÉ)
      helper (œÑ -and- Œì‚ä¢t‚ÇÅ:œÑ ‚àô _)
        = ‚àÑœÑ‚ü®Œì‚ä¢t‚ÇÅ:œÑ‚ü© (_ ‚Ü£ œÑ -and- Œì‚ä¢t‚ÇÅ:œÑ)

... | yes (base x -and- Œì‚ä¢t‚ÇÅ:base) | _ = no helper
    where
      helper : ‚àÑ[ œÉ ] (Œì ‚ä¢ t‚ÇÅ ‚àô t‚ÇÇ ‚à∂ œÉ)
      helper (œÑ -and- Œì‚ä¢t‚ÇÅ:_‚Ü£_ ‚àô _)
        with ‚ä¢-inj Œì‚ä¢t‚ÇÅ:_‚Ü£_ Œì‚ä¢t‚ÇÅ:base
      ...  | ()
\end{minted}
\end{frame}

\begin{frame}[fragile]{Typability III}
\begin{minted}{cagda}
-- Application case part II.
... | yes (œÑ‚ÇÅ ‚Ü£ œÑ‚ÇÇ -and- Œì‚ä¢t‚ÇÅ:œÑ‚ÇÅ‚Ü£œÑ‚ÇÇ) | no ‚àÑœÑ‚ü®Œì‚ä¢t‚ÇÇ:œÑ‚ü© = no helper
    where
      helper : ‚àÑ[ œÉ ] (Œì ‚ä¢ t‚ÇÅ ‚àô t‚ÇÇ ‚à∂ œÉ)
      helper (œÑ -and- Œì‚ä¢t‚ÇÅ:œÑ‚ÇÅ‚Ä≤‚Ü£œÑ‚ÇÇ‚Ä≤ ‚àô Œì‚ä¢t‚ÇÇ:œÑ)
        with ‚ä¢-inj Œì‚ä¢t‚ÇÅ:œÑ‚ÇÅ‚Ü£œÑ‚ÇÇ Œì‚ä¢t‚ÇÅ:œÑ‚ÇÅ‚Ä≤‚Ü£œÑ‚ÇÇ‚Ä≤
      ...  | refl = ‚àÑœÑ‚ü®Œì‚ä¢t‚ÇÇ:œÑ‚ü© (œÑ‚ÇÅ -and- Œì‚ä¢t‚ÇÇ:œÑ)

... | yes (œÑ‚ÇÅ ‚Ü£ œÑ‚ÇÇ -and- Œì‚ä¢t‚ÇÅ:œÑ‚ÇÅ‚Ü£œÑ‚ÇÇ) | yes (œÑ‚ÇÅ‚Ä≤ -and- Œì‚ä¢t‚ÇÇ:œÑ‚ÇÅ‚Ä≤)
    with œÑ‚ÇÅ T‚âü œÑ‚ÇÅ‚Ä≤
...  | yes œÑ‚ÇÅ‚â°œÑ‚ÇÅ‚Ä≤ = yes (œÑ‚ÇÇ -and- Œì‚ä¢t‚ÇÅ:œÑ‚ÇÅ‚Ü£œÑ‚ÇÇ ‚àô helper)
     where
       helper : Œì ‚ä¢ t‚ÇÇ ‚ÄÖ‚à∂ œÑ‚ÇÅ
       helper = subst (_‚ä¢_‚à∂_ Œì t‚ÇÇ) (sym œÑ‚ÇÅ‚â°œÑ‚ÇÅ‚Ä≤) Œì‚ä¢t‚ÇÇ:œÑ‚ÇÅ‚Ä≤
...  | no  œÑ‚ÇÅ‚â¢œÑ‚ÇÅ‚Ä≤ = no helper
     where
       helper : ‚àÑ[ œÉ ] (Œì ‚ä¢ t‚ÇÅ ‚àô t‚ÇÇ ‚à∂ œÉ)
       helper (_ -and- Œì‚ä¢t‚ÇÅ:œÑ‚Ü£œÑ‚ÇÇ ‚àô Œì‚ä¢t‚ÇÇ:œÑ‚ÇÅ)
         with ‚ä¢-inj  Œì‚ä¢t‚ÇÅ:œÑ‚Ü£œÑ‚ÇÇ Œì‚ä¢t‚ÇÅ:œÑ‚ÇÅ‚Ü£œÑ‚ÇÇ
       ...  | refl = œÑ‚ÇÅ‚â¢œÑ‚ÇÅ‚Ä≤ (‚ä¢-inj Œì‚ä¢t‚ÇÇ:œÑ‚ÇÅ Œì‚ä¢t‚ÇÇ:œÑ‚ÇÅ‚Ä≤)
\end{minted}
\end{frame}

\begin{frame}[fragile]{Type-checking I}
\begin{minted}{cagda}
check : ‚àÄ {n} Œì (t : Expr n) ‚Üí ‚àÄ œÑ ‚Üí Dec (Œì ‚ä¢ t ‚à∂ œÑ)

-- Var case.
check Œì (var x) œÑ with lookup x Œì T‚âü œÑ
... | yes refl = yes tVar
... | no ¬¨p    = no (¬¨p ‚àò ‚ä¢-inj tVar)

-- Abstraction case.
check Œì (lam œÑ t) (base A) = no (Œª ())
check Œì (lam œÑ t) (œÑ‚ÇÅ ‚Ü£ œÑ‚ÇÇ) with œÑ‚ÇÅ T‚âü œÑ
... | no œÑ‚ÇÅ‚â¢œÑ = no (œÑ‚ÇÅ‚â¢œÑ ‚àò helper)
    where
      helper : Œì ‚ä¢ lam œÑ t ‚à∂ (œÑ‚ÇÅ ‚Ü£ œÑ‚ÇÇ) ‚Üí œÑ‚ÇÅ ‚â° œÑ
      helper (tLam t) = refl

... | yes refl with check (œÑ ‚à∑ Œì) t œÑ‚ÇÇ
...               | yes Œì,œÑ‚ä¢t:œÑ‚ÇÇ = yes (tLam Œì,œÑ‚ä¢t:œÑ‚ÇÇ)
...               | no  Œì,œÑ‚ä¨t:œÑ‚ÇÇ = no helper
  where
    helper : ¬¨ Œì ‚ä¢ lam œÑ t ‚à∂ œÑ ‚Ü£ œÑ‚ÇÇ
    helper (tLam Œì,œÑ‚ä¢t:_) = Œì,œÑ‚ä¨t:œÑ‚ÇÇ Œì,œÑ‚ä¢t:_
\end{minted}
\end{frame}

\begin{frame}[fragile]{Type-checking II}
\begin{minted}{cagda}
-- Application case.
check Œì (t‚ÇÅ ‚àô t‚ÇÇ) œÉ with infer Œì t‚ÇÇ
... | yes (œÑ -and- Œì‚ä¢t‚ÇÇ:œÑ)
    with check Œì t‚ÇÅ (œÑ ‚Ü£ œÉ)
...    | yes Œì‚ä¢t‚ÇÅ:œÑ‚Ü£œÉ = yes (Œì‚ä¢t‚ÇÅ:œÑ‚Ü£œÉ ‚àô Œì‚ä¢t‚ÇÇ:œÑ)
...    | no  Œì‚ä¨t‚ÇÅ:œÑ‚Ü£œÉ = no helper
  where
    helper : ¬¨ Œì ‚ä¢ t‚ÇÅ ‚àô t‚ÇÇ ‚à∂ œÉ
    helper (Œì‚ä¢t‚ÇÅ:_‚Ü£_ ‚àô Œì‚ä¢t‚ÇÇ:œÑ‚Ä≤)
      with ‚ä¢-inj Œì‚ä¢t‚ÇÇ:œÑ Œì‚ä¢t‚ÇÇ:œÑ‚Ä≤
    ...  | refl = Œì‚ä¨t‚ÇÅ:œÑ‚Ü£œÉ Œì‚ä¢t‚ÇÅ:_‚Ü£_

check Œì (t‚ÇÅ ‚àô t‚ÇÇ) œÉ | no Œì‚ä¨t‚ÇÇ:_ = no helper
  where
    helper : ¬¨ Œì ‚ä¢ t‚ÇÅ ‚àô t‚ÇÇ ‚à∂ œÉ
    helper (_‚àô_ {œÑ = œÉ} t Œì‚ä¢t‚ÇÇ:œÑ‚Ä≤) = Œì‚ä¨t‚ÇÇ:_ (œÉ -and- Œì‚ä¢t‚ÇÇ:œÑ‚Ä≤)
\end{minted}
\end{frame}

\begin{frame}{References}
\printbibliography
\end{frame}


\end{document}