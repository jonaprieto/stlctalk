\documentclass[10pt, xetex, hyperref={pdfpagelabels=false,breaklinks}]{beamer}

% --------------------------------------------------------------------------
% Packages
% --------------------------------------------------------------------------
\usepackage[english]{babel}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{bussproofs}
\EnableBpAbbreviations
\def\extraVskip{3pt}

\usepackage{fancyvrb}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{lmodern}

\usepackage{url}


% --------------------------------------------------------------------------
% Tikz Configuration
% --------------------------------------------------------------------------
\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{calc}
\usepackage{rotating}

% --------------------------------------------------------------------------
% My palette.
% --------------------------------------------------------------------------
\definecolor{aliceblue}{rgb}{0.94, 0.97, 1.0}
\definecolor{energy}{RGB}{49,247,250}
\definecolor{delicate}{RGB}{67,179,223}
\definecolor{faded}{RGB}{76,117,195}
\definecolor{blu}{RGB}{1,0,102}
\definecolor{plum}{RGB}{87,78,164}
\definecolor{petunias}{RGB}{109,80,139}
\definecolor{letour}{RGB}{101,41,105}
\definecolor{carmine}{rgb}{0.59, 0.0, 0.09}
% --------------------------------------------------------------------------

% --------------------------------------------------------------------------
% Beamer configuration.
% --------------------------------------------------------------------------
\usetheme{default}
\usecolortheme{default}
\usefonttheme{serif}

\beamertemplatenavigationsymbolsempty
\setbeamertemplate{navigation symbols}{}
\hypersetup{pdfpagemode=UseNone}

% footer.
\setbeamercolor{headFoot}{fg=white, bg=blu}
\setbeamertemplate{footline}{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}
    [wd=.8\paperwidth,ht=2.3ex,dp=1ex,left]{headFoot}%
    \hspace*{2ex}\textbf\insertshorttitle\hspace*{2mm}|
    \hspace*{2mm}\textbf\insertshortauthor
  \end{beamercolorbox}%
  \begin{beamercolorbox}
    [wd=.2\paperwidth,ht=2.3ex,dp=1ex,right]{headFoot}%
    \insertframenumber{}/\inserttotalframenumber\hspace*{2ex}
  \end{beamercolorbox}}%
  \vskip 0pt%
}

\setbeamerfont{frametitle}{size=\small,series=\bfseries}
\setbeamercolor{frametitle}{fg=white,bg=blu}

\setbeamerfont{framesubtitle}{size=\normalfont\scriptsize}
\setbeamercolor{framesubtitle}{fg=white, bg=blu}

\setbeamercolor{background canvas}{bg=white}
\setbeamercolor{normal text}{fg=black}

% \setbeamercolor{institute}{fg=blu}
\setbeamercolor{title}{fg=blu}
\setbeamercolor{bibliography item}{fg=blu}
% \setbeamercolor{subtitle}{fg=blu}

% \setbeamercolor{titlelike}{fg=blu}
\setbeamerfont{footnote}{size=\tiny}
\setbeamercolor{footnote}{fg=gray}
\setbeamercolor{block title}{bg=white,fg=blu}
% \setbeamercolor{block body}{bg=aliceblue}
\setbeamercolor{item}{fg=blu} % color of bullets
\setbeamercolor{subitem}{fg=blu}
% \setbeamercolor{itemize/enumerate subbody}{fg=blu}
% \setbeamertemplate{itemize subitem}{{\textendash}}
% \setbeamerfont{itemize/enumerate subbody}{size=\footnotesize}
% \setbeamerfont{itemize/enumerate subitem}{size=\footnotesize}

% --------------------------------------------------------------------------
% Fonts
% --------------------------------------------------------------------------
\usefonttheme{professionalfonts}
\usefonttheme{serif}
\usepackage{fontspec}
\usepackage{mathtools}
\usepackage{unicode-math}

\setmonofont[ExternalLocation=fonts/
, BoldFont=DejaVuSansMono-Bold.ttf
, BoldItalicFont=DejaVuSansMono-BoldOblique.ttf
, ItalicFont=DejaVuSansMono-Oblique.ttf
]{DejaVuSansMono.ttf}

\setmathfont[ExternalLocation=fonts/
  , Colour=blu
  ]{DejaVuMathTeXGyre.ttf}
\newfontfamily\mathfont{fonts/DejaVuMathTeXGyre.ttf}

\setmainfont[ExternalLocation=fonts/
  , BoldFont=SourceSansPro-Semibold.otf
  , BoldItalicFont=SourceSansPro-SemiboldIt.otf
  , ItalicFont=SourceSansPro-It.otf
  ]{SourceSansPro-Regular.otf}

% --------------------------------------------------------------------------
% Agda Source code
% --------------------------------------------------------------------------

\usepackage{minted}
\setminted[cagda]{
  bgcolor   = aliceblue
, fontsize  = \footnotesize
, frame     = none
% , framerule = 0.4pt
% , framesep  = 0pt
, style     = cagda
}

% --------------------------------------------------------------------------
% References
% --------------------------------------------------------------------------

\usepackage[autostyle]{csquotes}
\usepackage[
    backend=biber
  , doi=false
  , eprint=false
  , isbn=false
  , natbib=true
  , sortlocale=en_US
  , style=authoryear-icomp
  , url=true
  , block=ragged
]{biblatex}
\addbibresource{ref.bib}
\renewcommand*{\nameyeardelim}{\addcomma\addspace}
\usepackage{silence}
\WarningFilter{biblatex}{Patching footnotes failed}
\WarningFilter{hyperref}{Token not allowed in a PDF string}

% --------------------------------------------------------------------------
% Title and Author
% --------------------------------------------------------------------------

\title[The Simply Typed Lambda Calculus]{The Simply Typed Lambda Calculus}

\subtitle{(In \texttt{Agda})}
\date{\footnotesize 1th June 2017}
\author[Jonathan Prieto-Cubides]{Jonathan Prieto-Cubides}
\institute{
Master in Applied Mathematics\\
Logic and Computation Group\\
Universidad EAFIT\\
Medell\'in, Colombia}
% --------------------------------------------------------------------------

\newsavebox\agdapragma

\begin{document}
\setcounter{page}{1}

\begin{frame}[plain]
\titlepage
  \begin{tikzpicture}[overlay, remember picture]
   \tikzset{shift={(current page.center)}}
    \node[xshift=0cm,yshift=-3.2cm] (eafit)
      {\includegraphics[width=0.2\textwidth]{figures/eafit}};
  \end{tikzpicture}
\end{frame}


\begin{frame}{Contents}
\tableofcontents
\end{frame}

\begin{frame}{About}
\begin{itemize}
\item The Agda source code of this talk is available in the repository
{\color{plum}
\begin{center}
\href{https://github.com/jonaprieto/stlctalk}{https://github.com/jonaprieto/stlctalk}.
\end{center}
}
We present a refactor of the implementation by \citep{cactus} for the simple lambda calculus,
specifically in the Scopecheck and Typecheck module.
\item Tested with Agda v$2.5.2$ and Agda Standard Library v$0.13$
\end{itemize}
\end{frame}

\section{Lambda Calculus}
\begin{frame}[fragile]{Lambda Calculus}
\begin{definition}
\begin{itemize}
\item The set of $\lambda$-terms denoted by $\Lambda$ is built up
from a set of variables $V$ using application and (function) abstraction
\begin{align*}
x\in V                &\Rightarrow x\in \Lambda, \\
M\in \Lambda, x\in V  &\Rightarrow (\lambda x. M) \in \Lambda,\\
M, N\in \Lambda       &\Rightarrow (MN) \in \Lambda.
\end{align*}
\item A simple syntax definition for lambda terms
\vskip 1.5mm
\begin{minted}{cagda}
Name : Set
Name = String

data Expr : Set where
  var : Name â†’ Expr
  lam : Name â†’ Expr â†’ Expr
  _âˆ™_ : Expr â†’ Expr â†’ Expr
\end{minted}
\end{itemize}
\end{definition}
\end{frame}

\section{Typed Lambda Calculus}
\begin{frame}{Lambda Curry System}
\begin{itemize}
\item The set of types is noted with $ğ•‹ =\text{ Type}(\lambda\rightarrow)$.
$$ğ•‹ = ğ•\, |\, ğ”¹\, |\, ğ•‹ â†£ ğ•‹,$$
where $ğ• = \{Î±â‚,Î±â‚‚, \cdots \}$ be a set of type variables,
$ğ”¹$ stands for a collection of type constants for basic types
like \texttt{Nat} or \texttt{Bool}
\item A \emph{statement} is of the form $M : Ïƒ$ with $M âˆˆ Î›$ and $Ïƒ âˆˆ ğ•‹$
\item \emph{Derivation} inference rules
\vskip 1mm
\begin{columns}
  \begin{column}{0.5\textwidth}
    \begin{prooftree}
    \AxiomC{$M : Ïƒ â†£ Ï„$}
    \AxiomC{$N : Ïƒ$}
    \BinaryInfC{$MN : Ï„$}
    \end{prooftree}
  \end{column}
  \begin{column}{0.5\textwidth}
    \begin{prooftree}
    \AxiomC{$[x : \sigma]^{(1)}$}
    \UnaryInfC{$\vdots$}
    \UnaryInfC{$M : \tau$}
    \RightLabel{\scriptsize (1)}
    \UnaryInfC{$Î»x.M : Ïƒ â†£ \tau$}
    \end{prooftree}
  \end{column}
\end{columns}
\vskip 1mm
\item A statement $M : \sigma$ is derivable form a \textit{basis} $Î“$ denoted
by $Î“ âŠ¢ M : Ïƒ$ where basis stands for be a set of statements with only distinct
(term) variables as subjects
\end{itemize}
\end{frame}

\section{Syntax Definitions}
\begin{frame}[fragile]{Syntax defintion based on ~\citep{cactus}, and \citep{nad}}
\begin{itemize}
  \item Typing syntax: $ğ•‹ = ğ•\, |\, ğ”¹\, |\, ğ•‹ â†£ ğ•‹$,
  \vskip 1.5mm
\begin{minted}{cagda}
module Typing (U : Set) where

data Type : Set where
  base : U    â†’ Type
  _â†£_  : Type â†’ Type â†’ Type
\end{minted}

\item A syntax definition including type annotations
\vskip 1.5mm
\begin{minted}{cagda}
module Syntax (Type : Set) where

open import Data.String

Name : Set
Name = String

data Formal : Set where
  _âˆ¶_ : Name â†’ Type â†’ Formal

data Expr : Set where
  var : Name   â†’ Expr
  lam : Formal â†’ Expr â†’ Expr
  _âˆ™_ : Expr   â†’ Expr â†’ Expr
\end{minted}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Examples}
\begin{minted}{cagda}
open import Syntax Type

postulate A : Type

x = var "x"
y = var "y"
z = var "z"

-- Combinators.
-- I, K, S : Expr

I = lam ("x" âˆ¶ A) x                  -- Î»x.x, x : A
K = lam ("x" âˆ¶ A) (lam ("y" âˆ¶ A) x)  -- Î»xy.x, x,y : A
S =
  lam ("x" âˆ¶ A)
    (lam ("y" âˆ¶ A)
      (lam ("z" âˆ¶ A)
        ((x âˆ™ z) âˆ™ (y âˆ™ z))))        -- Î»xyz.xz(yz), x,y,z : A
\end{minted}
\end{frame}

\section{Decibility of Type Assignment}
\begin{frame}{Decibility of Type Assignment~\citep{barendregt2013lambda}}

\begin{tabular}{ll}
{\color{blu} \textbf{Problem}} & {\color{blu} \textbf{Question}} \\
{\color{blu} Typability}       & Given $M$ does exists a $Ïƒ$ such that $Î“ âŠ¢ M : Ïƒ$? \\
{\color{blu} Type-checking}    & Given $M$ and $Ï„$, can we have $Î“ âŠ¢ M : Ï„$?  \\
{\color{blu} Inhabitation}     & Given $Ï„$, does exists an $M$ such that $Î“ âŠ¢ M : Ïƒ$?\\
\end{tabular}

\begin{theorem}%[Typability]
\begin{itemize}
\item It is decidable whether a term is typable in $\lambda\rightarrow$.
\item If a term $M$ is typable in $\lambda\rightarrow$, then M has a principal type scheme, i.e.
a type $Ïƒ$ such that every possible type for $M$ is a subsitution instance of $Ïƒ$.
Moreover $Ïƒ$ is computable from $M$.
\end{itemize}
\end{theorem}

\begin{theorem}%[Type-checking]
Type checking for $\lambda\rightarrow$ is decidable.
\end{theorem}

\end{frame}

\section{Well-Scoped Lambda Expressions}
\begin{frame}[fragile]{De Bruijn Index}
\begin{itemize}
\item The indexes are natural numbers that represent the occurrences of the variable in a Î»-term
$$  Î»x. Î»y. x â‡  Î» Î» 2$$
\item The natural number denotes the number of binders that are in scope between that occurrence and its corresponding binder
$$Î»x. Î»y. Î»z. x z (y z)  â‡ Î» Î» Î» 3 1 (2 1)$$
\item Check for $Î±$-equivalence is the same as that for syntactic equality
\item A syntax definition using De Bruijn indexes\\[3mm]
\begin{minted}{cagda}
data Expr (n : â„•) : Set where
  var : Fin n  â†’ Expr n
  lam : Type   â†’ Expr (suc n) â†’ Expr n
  _âˆ™_ : Expr n â†’ Expr n       â†’ Expr n
\end{minted}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{\texttt{module Bound (Type : Set) where}}
% Well-scoped Expresions with respect to a variable Binder.
\begin{minted}{cagda}
Binder : â„• â†’ Set
Binder = Vec Name

data _âŠ¢_â‡_ : âˆ€ {n} â†’ Binder n â†’ S.Expr â†’ Expr n â†’ Set where

  var-zero : âˆ€ {n x} {Î“ : Binder n}
           â†’ Î“ , x âŠ¢ var x â‡ var (# 0)

  var-suc  : âˆ€ {n x y k} {Î“ : Binder n} {p : False (x â‰Ÿ y)}
           â†’ Î“ âŠ¢ var x â‡ var k
           â†’ Î“ , y âŠ¢ var x â‡ var (suc k)

  lam      : âˆ€ {n x Ï„ t tâ€²} {Î“ : Binder n}
           â†’ Î“ , x âŠ¢ t â‡ tâ€²
           â†’ Î“ âŠ¢ lam (x âˆ¶ Ï„) t â‡ lam Ï„ tâ€²

  _âˆ™_      : âˆ€ {n tâ‚ tâ‚â€² tâ‚‚ tâ‚‚â€²} {Î“ : Binder n}
           â†’ Î“ âŠ¢ tâ‚ â‡ tâ‚â€²
           â†’ Î“ âŠ¢ tâ‚‚ â‡ tâ‚‚â€²
           â†’ Î“ âŠ¢ tâ‚ âˆ™ tâ‚‚ â‡ tâ‚â€² âˆ™ tâ‚‚â€²
\end{minted}
\end{frame}

\begin{frame}[fragile]{Examples}
\begin{minted}{cagda}
âˆ… : Binder 0
âˆ… = []

Î“ : Binder 2
Î“ = "x" âˆ· "y" âˆ· []

e1 : "x" âˆ· "y" âˆ· [] âŠ¢ var "x" â‡ var (# 0)
e1 = var-zero

I : [] âŠ¢ lam ("x" âˆ¶ A) (var "x")
       â‡ lam A (var (# 0))
I = lam var-zero

K : [] âŠ¢ lam ("x" âˆ¶ A) (lam ("y" âˆ¶ A) (var "x"))
       â‡ lam A (lam A (var (# 1)))
K = lam (lam (var-suc var-zero))

Kâ‚‚ : [] âŠ¢ lam ("x" âˆ¶ A) (lam ("y" âˆ¶ A) (var "y"))
        â‡ lam A (lam A (var (# 0)))
Kâ‚‚ = lam (lam var-zero)

P : Î“ âŠ¢ lam ("x" âˆ¶ A) (lam ("y" âˆ¶ A) (lam ("z" âˆ¶ A) (var "x")))
      â‡ lam A (lam A (lam A (var (# 2))))
P = {!!}   -- complete!!
\end{minted}
\end{frame}

\begin{frame}[fragile]{\texttt{module Scopecheck (Type : Set) where}}
\begin{minted}{cagda}
name-dec : âˆ€ {n} {Î“ : Binder n} {x y : Name} {t : Expr (suc n)}
         â†’ Î“ , y âŠ¢ var x â‡ t
         â†’ x â‰¡ y âŠ âˆƒ[ tâ€² ] (Î“ âŠ¢ var x â‡ tâ€²)

âŠ¢subst : âˆ€ {n} {x y} {Î“ : Binder n} {t}
       â†’ x â‰¡ y
       â†’ Î“ , x âŠ¢ var x â‡ t
       â†’ Î“ , y âŠ¢ var x â‡ t

find-name : âˆ€ {n}
          â†’ (Î“ : Binder n)
          â†’ (x : Name)
          â†’ Dec (âˆƒ[ t ] (Î“ âŠ¢ var x â‡ t))

check : âˆ€ {n}
      â†’ (Î“ : Binder n)
      â†’ (t : S.Expr)
      â†’ Dec (âˆƒ[ tâ€² ] (Î“ âŠ¢ t â‡ tâ€²))

scope : (t : S.Expr) â†’ {p : True (check [] t)} â†’ Expr 0
scope t {p} = projâ‚ (toWitness p)
\end{minted}
\end{frame}

\begin{frame}[fragile]{Examples}
\begin{minted}{cagda}
postulate A : Type

Iâ‚ : S.Expr
Iâ‚ = S.lam ("x" âˆ¶ A) (S.var "x")

open import Data.Unit

I = scope Iâ‚ {p = âŠ¤.tt}  -- Use C-C-C-n and check for I.

x, y, z : S.Expr
x = var "x"
y = var "y"
z = var "z"

Sâ‚ =
  lam ("x" âˆ¶ A)
    (lam ("y" âˆ¶ A)
      (lam ("z" âˆ¶ A)
        ((x âˆ™ z) âˆ™ (y âˆ™ z))))

S : Expr 0
S = scope Sâ‚ {p = âŠ¤.tt}  -- Use C-C-C-n and check for S.
\end{minted}
\end{frame}


\begin{frame}{Typing Rules}
\begin{itemize}
\item Introduction\\
\begin{prooftree}
\AxiomC{$Î“(t) = \tau$}
\UnaryInfC{$Î“ âŠ¢ t : \tau$}
\end{prooftree}\hfill

\item Abstraction\\
\begin{prooftree}
\AxiomC{$Î“ , Ï„ âŠ¢ t : Ïƒ$}
\UnaryInfC{$Î“ âŠ¢ Î»\ Ï„\ t âˆ¶ Ï„ â†£ \sigma$}
\end{prooftree}\hfill

\item Application
\begin{prooftree}
\AxiomC{$Î“ âŠ¢ tâ‚ : Ï„ â†£ Ïƒ$}
\AxiomC{$Î“ âŠ¢ tâ‚‚ : Ï„$}
\BinaryInfC{$Î“ âŠ¢ tâ‚ âˆ™ tâ‚‚ âˆ¶ Ïƒ$}
\end{prooftree}\hfill
\end{itemize}

\end{frame}

\section{Typability and Type-checking}
\begin{frame}[fragile]{\texttt{module Typing (U : Set) where}}
\begin{minted}{cagda}
open import Bound Type hiding (_,_)

Ctxt : â„• â†’ Set
Ctxt = Vec Type

_,_ : âˆ€ {n} â†’ Ctxt n â†’ Type â†’ Ctxt (suc n)
Î“ , x = x âˆ· Î“

data _âŠ¢_âˆ¶_ : âˆ€ {n} â†’ Ctxt n â†’ Expr n â†’ Type â†’ Set where

  tVar : âˆ€ {n Î“} {x : Fin n}
       â†’ Î“ âŠ¢ var x âˆ¶ lookup x Î“

  tLam : âˆ€ {n} {Î“ : Ctxt n} {t} {Ï„ Ïƒ}
       â†’ Î“ , Ï„ âŠ¢ t âˆ¶ Ïƒ
       â†’ Î“ âŠ¢ lam Ï„ t âˆ¶ Ï„ â†£ Ïƒ

  _âˆ™_  : âˆ€ {n} {Î“ : Ctxt n} {tâ‚ tâ‚‚} {Ï„ Ïƒ}
       â†’ Î“ âŠ¢ tâ‚ âˆ¶ Ï„ â†£ Ïƒ
       â†’ Î“ âŠ¢ tâ‚‚ âˆ¶ Ï„
       â†’ Î“ âŠ¢ tâ‚ âˆ™ tâ‚‚ âˆ¶ Ïƒ
\end{minted}
\end{frame}

\begin{frame}[fragile]{Examples}
\begin{minted}{cagda}
postulate
  Bool : Type

ex : [] , Bool âŠ¢ var (# 0) âˆ¶ Bool
ex = tVar

ex2 : [] âŠ¢ lam Bool (var (# 0)) âˆ¶ Bool â†£ Bool
ex2 = tLam tVar

postulate
  Word : Type
  Num  : Type

K : [] âŠ¢ lam Word (lam Num (var (# 1))) âˆ¶ Word â†£ Num â†£ Word
K = tLam (tLam tVar)
\end{minted}
\end{frame}


\begin{frame}[fragile]{Equality Between Types}
\begin{minted}{cagda}
_Tâ‰Ÿ_ : (Ï„ Ï„â€² : Type) â†’ Dec (Ï„ â‰¡ Ï„â€²)
base A Tâ‰Ÿ base B with A â‰Ÿ B
... | yes Aâ‰¡B = yes (cong base Aâ‰¡B)
... | no  Aâ‰¢B = no (Aâ‰¢B âˆ˜ helper)
  where
    helper : base A â‰¡ base B â†’ A â‰¡ B
    helper refl = refl
base A Tâ‰Ÿ (_ â†£ _) = no (Î» ())

(Ï„â‚ â†£ Ï„â‚‚) Tâ‰Ÿ base B = no (Î» ())
(Ï„â‚ â†£ Ï„â‚‚) Tâ‰Ÿ (Ï„â‚â€² â†£ Ï„â‚‚â€²) with Ï„â‚ Tâ‰Ÿ Ï„â‚â€²
... | no  Ï„â‚â‰¢Ï„â‚â€² = no (Ï„â‚â‰¢Ï„â‚â€² âˆ˜ helper)
  where
    helper :  Ï„â‚ â†£ Ï„â‚‚ â‰¡ Ï„â‚â€² â†£ Ï„â‚‚â€² â†’ Ï„â‚ â‰¡ Ï„â‚â€²
    helper refl = refl
... | yes Ï„â‚â‰¡Ï„â‚â€²
  with Ï„â‚‚ Tâ‰Ÿ Ï„â‚‚â€²
...  | yes Ï„â‚‚â‰¡Ï„â‚‚â€² = yes (congâ‚‚ _â†£_ Ï„â‚â‰¡Ï„â‚â€² Ï„â‚‚â‰¡Ï„â‚‚â€²)
...  | no  Ï„â‚‚â‰¢Ï„â‚‚â€² = no (Ï„â‚‚â‰¢Ï„â‚‚â€² âˆ˜ helper)
  where
    helper : Ï„â‚ â†£ Ï„â‚‚ â‰¡ Ï„â‚â€² â†£ Ï„â‚‚â€² â†’ Ï„â‚‚ â‰¡ Ï„â‚‚â€²
    helper refl = refl
\end{minted}
\end{frame}
\begin{frame}[fragile]{An Example of an Useful Theorem}
\begin{minted}{cagda}
-- Auxiliar Helper.
âŠ¢-inj : âˆ€ {n Î“} {t : Expr n} â†’ âˆ€ {Ï„ Ïƒ}
      â†’ Î“ âŠ¢ t âˆ¶ Ï„
      â†’ Î“ âŠ¢ t âˆ¶ Ïƒ
      â†’ Ï„ â‰¡ Ïƒ

-- Var case.
âŠ¢-inj tVar tVar = refl

-- Abstraction case.
âŠ¢-inj {t = lam Ï„ t} (tLam Î“,Ï„âŠ¢t:Ï„â€²) (tLam Î“,Ï„âŠ¢t:Ï„â€³)
  = cong (_â†£_ Ï„) (âŠ¢-inj Î“,Ï„âŠ¢t:Ï„â€² Î“,Ï„âŠ¢t:Ï„â€³)

-- Application case.
âŠ¢-inj (Î“âŠ¢tâ‚:Ï„â†£Ï„â‚‚ âˆ™ Î“âŠ¢tâ‚‚:Ï„) (Î“âŠ¢tâ‚:Ï„â‚â†£Ïƒ âˆ™ Î“âŠ¢tâ‚‚:Ï„â‚)
  = helper (âŠ¢-inj Î“âŠ¢tâ‚:Ï„â†£Ï„â‚‚ Î“âŠ¢tâ‚:Ï„â‚â†£Ïƒ)
  where
    helper : âˆ€ {Ï„ Ï„â‚‚ Ï„â‚ Ïƒ} â†’ (Ï„ â†£ Ï„â‚‚ â‰¡ Ï„â‚ â†£ Ïƒ) â†’ Ï„â‚‚ â‰¡ Ïƒ
    helper refl = refl
\end{minted}
\end{frame}

\begin{frame}[fragile]{Typability I}
\begin{minted}{cagda}
infer : âˆ€ {n} Î“ (t : Expr n) â†’ Dec (âˆƒ[ Ï„ ] (Î“ âŠ¢ t âˆ¶ Ï„))

-- Var case.
infer Î“ (var x) = yes (lookup x Î“ -and- tVar)

-- Abstraction case.
infer Î“ (lam Ï„ t) with infer (Ï„ âˆ· Î“) t
... | yes (Ïƒ -and- Î“,Ï„âŠ¢t:Ïƒ) = yes (Ï„ â†£ Ïƒ -and- tLam Î“,Ï„âŠ¢t:Ïƒ)
... | no  Î“,Ï„âŠ¬t:Ïƒ = no helper
  where
    helper : âˆ„[ Ï„â€² ] (Î“ âŠ¢ lam Ï„ t âˆ¶ Ï„â€²)
    helper (base A -and- ())
    helper (.Ï„ â†£ Ïƒ -and- tLam Î“,Ï„âŠ¢t:Ïƒ)
      = Î“,Ï„âŠ¬t:Ïƒ (Ïƒ -and- Î“,Ï„âŠ¢t:Ïƒ)
\end{minted}
\end{frame}

\begin{frame}[fragile]{Typability II}
\begin{minted}{cagda}
-- Application case part I.
infer Î“ (tâ‚ âˆ™ tâ‚‚) with infer Î“ tâ‚ | infer Î“ tâ‚‚
... | no  âˆ„Ï„âŸ¨Î“âŠ¢tâ‚:Ï„âŸ© | _ = no helper
    where
      helper : âˆ„[ Ïƒ ] (Î“ âŠ¢ tâ‚ âˆ™ tâ‚‚ âˆ¶ Ïƒ)
      helper (Ï„ -and- Î“âŠ¢tâ‚:Ï„ âˆ™ _)
        = âˆ„Ï„âŸ¨Î“âŠ¢tâ‚:Ï„âŸ© (_ â†£ Ï„ -and- Î“âŠ¢tâ‚:Ï„)

... | yes (base x -and- Î“âŠ¢tâ‚:base) | _ = no helper
    where
      helper : âˆ„[ Ïƒ ] (Î“ âŠ¢ tâ‚ âˆ™ tâ‚‚ âˆ¶ Ïƒ)
      helper (Ï„ -and- Î“âŠ¢tâ‚:_â†£_ âˆ™ _)
        with âŠ¢-inj Î“âŠ¢tâ‚:_â†£_ Î“âŠ¢tâ‚:base
      ...  | ()
\end{minted}
\end{frame}

\begin{frame}[fragile]{Typability III}
\begin{minted}{cagda}
-- Application case part II.
... | yes (Ï„â‚ â†£ Ï„â‚‚ -and- Î“âŠ¢tâ‚:Ï„â‚â†£Ï„â‚‚) | no âˆ„Ï„âŸ¨Î“âŠ¢tâ‚‚:Ï„âŸ© = no helper
    where
      helper : âˆ„[ Ïƒ ] (Î“ âŠ¢ tâ‚ âˆ™ tâ‚‚ âˆ¶ Ïƒ)
      helper (Ï„ -and- Î“âŠ¢tâ‚:Ï„â‚â€²â†£Ï„â‚‚â€² âˆ™ Î“âŠ¢tâ‚‚:Ï„)
        with âŠ¢-inj Î“âŠ¢tâ‚:Ï„â‚â†£Ï„â‚‚ Î“âŠ¢tâ‚:Ï„â‚â€²â†£Ï„â‚‚â€²
      ...  | refl = âˆ„Ï„âŸ¨Î“âŠ¢tâ‚‚:Ï„âŸ© (Ï„â‚ -and- Î“âŠ¢tâ‚‚:Ï„)

... | yes (Ï„â‚ â†£ Ï„â‚‚ -and- Î“âŠ¢tâ‚:Ï„â‚â†£Ï„â‚‚) | yes (Ï„â‚â€² -and- Î“âŠ¢tâ‚‚:Ï„â‚â€²)
    with Ï„â‚ Tâ‰Ÿ Ï„â‚â€²
...  | yes Ï„â‚â‰¡Ï„â‚â€² = yes (Ï„â‚‚ -and- Î“âŠ¢tâ‚:Ï„â‚â†£Ï„â‚‚ âˆ™ helper)
     where
       helper : Î“ âŠ¢ tâ‚‚ â€…âˆ¶ Ï„â‚
       helper = subst (_âŠ¢_âˆ¶_ Î“ tâ‚‚) (sym Ï„â‚â‰¡Ï„â‚â€²) Î“âŠ¢tâ‚‚:Ï„â‚â€²
...  | no  Ï„â‚â‰¢Ï„â‚â€² = no helper
     where
       helper : âˆ„[ Ïƒ ] (Î“ âŠ¢ tâ‚ âˆ™ tâ‚‚ âˆ¶ Ïƒ)
       helper (_ -and- Î“âŠ¢tâ‚:Ï„â†£Ï„â‚‚ âˆ™ Î“âŠ¢tâ‚‚:Ï„â‚)
         with âŠ¢-inj  Î“âŠ¢tâ‚:Ï„â†£Ï„â‚‚ Î“âŠ¢tâ‚:Ï„â‚â†£Ï„â‚‚
       ...  | refl = Ï„â‚â‰¢Ï„â‚â€² (âŠ¢-inj Î“âŠ¢tâ‚‚:Ï„â‚ Î“âŠ¢tâ‚‚:Ï„â‚â€²)
\end{minted}
\end{frame}

\begin{frame}[fragile]{Type-checking I}
\begin{minted}{cagda}
check : âˆ€ {n} Î“ (t : Expr n) â†’ âˆ€ Ï„ â†’ Dec (Î“ âŠ¢ t âˆ¶ Ï„)

-- Var case.
check Î“ (var x) Ï„ with lookup x Î“ Tâ‰Ÿ Ï„
... | yes refl = yes tVar
... | no Â¬p    = no (Â¬p âˆ˜ âŠ¢-inj tVar)

-- Abstraction case.
check Î“ (lam Ï„ t) (base A) = no (Î» ())
check Î“ (lam Ï„ t) (Ï„â‚ â†£ Ï„â‚‚) with Ï„â‚ Tâ‰Ÿ Ï„
... | no Ï„â‚â‰¢Ï„ = no (Ï„â‚â‰¢Ï„ âˆ˜ helper)
    where
      helper : Î“ âŠ¢ lam Ï„ t âˆ¶ (Ï„â‚ â†£ Ï„â‚‚) â†’ Ï„â‚ â‰¡ Ï„
      helper (tLam t) = refl

... | yes refl with check (Ï„ âˆ· Î“) t Ï„â‚‚
...               | yes Î“,Ï„âŠ¢t:Ï„â‚‚ = yes (tLam Î“,Ï„âŠ¢t:Ï„â‚‚)
...               | no  Î“,Ï„âŠ¬t:Ï„â‚‚ = no helper
  where
    helper : Â¬ Î“ âŠ¢ lam Ï„ t âˆ¶ Ï„ â†£ Ï„â‚‚
    helper (tLam Î“,Ï„âŠ¢t:_) = Î“,Ï„âŠ¬t:Ï„â‚‚ Î“,Ï„âŠ¢t:_
\end{minted}
\end{frame}

\begin{frame}[fragile]{Type-checking II}
\begin{minted}{cagda}
-- Application case.
check Î“ (tâ‚ âˆ™ tâ‚‚) Ïƒ with infer Î“ tâ‚‚
... | yes (Ï„ -and- Î“âŠ¢tâ‚‚:Ï„)
    with check Î“ tâ‚ (Ï„ â†£ Ïƒ)
...    | yes Î“âŠ¢tâ‚:Ï„â†£Ïƒ = yes (Î“âŠ¢tâ‚:Ï„â†£Ïƒ âˆ™ Î“âŠ¢tâ‚‚:Ï„)
...    | no  Î“âŠ¬tâ‚:Ï„â†£Ïƒ = no helper
  where
    helper : Â¬ Î“ âŠ¢ tâ‚ âˆ™ tâ‚‚ âˆ¶ Ïƒ
    helper (Î“âŠ¢tâ‚:_â†£_ âˆ™ Î“âŠ¢tâ‚‚:Ï„â€²)
      with âŠ¢-inj Î“âŠ¢tâ‚‚:Ï„ Î“âŠ¢tâ‚‚:Ï„â€²
    ...  | refl = Î“âŠ¬tâ‚:Ï„â†£Ïƒ Î“âŠ¢tâ‚:_â†£_

check Î“ (tâ‚ âˆ™ tâ‚‚) Ïƒ | no Î“âŠ¬tâ‚‚:_ = no helper
  where
    helper : Â¬ Î“ âŠ¢ tâ‚ âˆ™ tâ‚‚ âˆ¶ Ïƒ
    helper (_âˆ™_ {Ï„ = Ïƒ} t Î“âŠ¢tâ‚‚:Ï„â€²) = Î“âŠ¬tâ‚‚:_ (Ïƒ -and- Î“âŠ¢tâ‚‚:Ï„â€²)
\end{minted}
\end{frame}

\begin{frame}{References}
\printbibliography
\end{frame}


\end{document}