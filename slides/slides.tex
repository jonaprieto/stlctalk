\documentclass[10pt, xetex, hyperref={pdfpagelabels=false}]{beamer}

% --------------------------------------------------------------------------
% Packages
% --------------------------------------------------------------------------
\usepackage[english]{babel}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{bussproofs}
\EnableBpAbbreviations
\def\extraVskip{3pt}

\usepackage{fancyvrb}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{lmodern}

\usepackage{url}

% --------------------------------------------------------------------------
% Tikz Configuration
% --------------------------------------------------------------------------
\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{calc}
\usepackage{rotating}

% --------------------------------------------------------------------------
% My palette.
% --------------------------------------------------------------------------
\definecolor{aliceblue}{rgb}{0.94, 0.97, 1.0}
\definecolor{energy}{RGB}{49,247,250}
\definecolor{delicate}{RGB}{67,179,223}
\definecolor{faded}{RGB}{76,117,195}
\definecolor{blu}{RGB}{1,0,102}
\definecolor{plum}{RGB}{87,78,164}
\definecolor{petunias}{RGB}{109,80,139}
\definecolor{letour}{RGB}{101,41,105}
% --------------------------------------------------------------------------

% --------------------------------------------------------------------------
% Beamer configuration.
% --------------------------------------------------------------------------
\usetheme{default}
\usecolortheme{default}
\usefonttheme{serif}

\beamertemplatenavigationsymbolsempty
\setbeamertemplate{navigation symbols}{}
\hypersetup{pdfpagemode=UseNone}

% footer.
\setbeamercolor{headFoot}{fg=white, bg=blu}
\setbeamertemplate{footline}{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}
    [wd=.8\paperwidth,ht=2.3ex,dp=1ex,left]{headFoot}%
    \hspace*{2ex}\textbf\insertshorttitle\hspace*{2mm}|
    \hspace*{2mm}\textbf\insertshortauthor
  \end{beamercolorbox}%
  \begin{beamercolorbox}
    [wd=.2\paperwidth,ht=2.3ex,dp=1ex,right]{headFoot}%
    \insertframenumber{}/\inserttotalframenumber\hspace*{2ex}
  \end{beamercolorbox}}%
  \vskip 0pt%
}

\setbeamerfont{frametitle}{size=\small,series=\bfseries}
\setbeamercolor{frametitle}{fg=white,bg=blu}

\setbeamerfont{framesubtitle}{size=\normalfont\scriptsize}
\setbeamercolor{framesubtitle}{fg=white, bg=blu}

\setbeamercolor{background canvas}{bg=white}
\setbeamercolor{normal text}{fg=black}

% \setbeamercolor{institute}{fg=blu}
\setbeamercolor{title}{fg=blu}
% \setbeamercolor{subtitle}{fg=blu}

% \setbeamercolor{titlelike}{fg=blu}
\setbeamerfont{footnote}{size=\tiny}
\setbeamercolor{footnote}{fg=gray}
\setbeamercolor{block title}{bg=white,fg=blu}
% \setbeamercolor{block body}{bg=aliceblue}
\setbeamercolor{item}{fg=blu} % color of bullets
\setbeamercolor{subitem}{fg=blu}
% \setbeamercolor{itemize/enumerate subbody}{fg=blu}
% \setbeamertemplate{itemize subitem}{{\textendash}}
% \setbeamerfont{itemize/enumerate subbody}{size=\footnotesize}
% \setbeamerfont{itemize/enumerate subitem}{size=\footnotesize}

% --------------------------------------------------------------------------
% Fonts
% --------------------------------------------------------------------------
\usefonttheme{professionalfonts}
\usefonttheme{serif}
\usepackage{fontspec}
\usepackage{mathtools}
\usepackage{unicode-math}

\newfontfamily\djvu[ExternalLocation=fonts/
  , BoldFont=DejaVuSansMono-Bold.ttf
  , BoldItalicFont=DejaVuSansMono-BoldOblique.ttf
  , ItalicFont=DejaVuSansMono-Oblique.ttf
  ]{DejaVuSansMono.ttf}

\setmonofont[ExternalLocation=fonts/
, BoldFont=DejaVuSansMono-Bold.ttf
, BoldItalicFont=DejaVuSansMono-BoldOblique.ttf
, ItalicFont=DejaVuSansMono-Oblique.ttf
]{DejaVuSansMono.ttf}

\setmathfont[ExternalLocation=fonts/
  ]{DejaVuMathTeXGyre.ttf}
\newfontfamily\mathfont{fonts/DejaVuMathTeXGyre.ttf}

\setmainfont[ExternalLocation=fonts/
  , BoldFont=SourceSansPro-Semibold.otf
  , BoldItalicFont=SourceSansPro-SemiboldIt.otf
  , ItalicFont=SourceSansPro-It.otf
  ]{SourceSansPro-Regular.otf}

% \setmonofont[ExternalLocation=fonts/
%   , BoldFont=SourceCodePro-Semibold.ttf
%   , BoldItalicFont=SourceCodePro-SemiboldIt.ttf
%   , ItalicFont=SourceCodePro-It.ttf
%   ]{SourceCodePro-Regular.ttf}

\newfontfamily\sourcecode[ExternalLocation=fonts/
  , BoldFont=SourceCodePro-Semibold.ttf
  , BoldItalicFont=SourceCodePro-SemiboldIt.ttf
  , ItalicFont=SourceCodePro-It.ttf
  ]{SourceCodePro-Regular.ttf}

% --------------------------------------------------------------------------
% Agda Source code
% --------------------------------------------------------------------------

\usepackage{minted}
\setminted[cagda]{
  bgcolor   = aliceblue
, fontsize  = \footnotesize
, frame     = none
% , framerule = 0.4pt
% , framesep  = 0pt
, style     = cagda
}

% --------------------------------------------------------------------------
% References
% --------------------------------------------------------------------------

\usepackage[autostyle]{csquotes}
\usepackage[
    backend=biber
  , doi=false
  , eprint=false
  , isbn=false
  , natbib=true
  , sortlocale=en_US
  , style=authoryear-icomp
  , url=false
]{biblatex}
\addbibresource{ref.bib}
\renewcommand*{\nameyeardelim}{\addcomma\addspace}
\usepackage{silence}
\WarningFilter{biblatex}{Patching footnotes failed}
\WarningFilter{hyperref}{Token not allowed in a PDF string}

% --------------------------------------------------------------------------
% Title and Author
% --------------------------------------------------------------------------

\title[The Simply Typed $\lambda$-Calculus]{The Simply Typed $\lambda$-Calculus}

\subtitle{(In \texttt{Agda})}
\date{\footnotesize 1th June 2017}
\author[Jonathan Prieto-Cubides]{Jonathan Prieto-Cubides}
\institute{
Master in Applied Mathematics\\
Logic and Computation Group\\
Universidad EAFIT\\
Medell\'in, Colombia}
% --------------------------------------------------------------------------

\newsavebox\agdapragma

\begin{document}
\setcounter{page}{1}

\begin{frame}[plain]
\titlepage
  \begin{tikzpicture}[overlay, remember picture]
   \tikzset{shift={(current page.center)}}
    \node[xshift=0cm,yshift=-3.2cm] (eafit)
      {\includegraphics[width=0.2\textwidth]{figures/eafit}};
  \end{tikzpicture}
\end{frame}


\begin{frame}{Contents}
\tableofcontents
\end{frame}

\section{Lambda Calculus}
\begin{frame}[fragile]{$\lambda$-Calculus}
\begin{definition}
The set of $\lambda$-terms denoted by $\Lambda$ is built up
from a set of variables $V$ using application and (function) abstraction.
\begin{align*}
x\in V                  &\Rightarrow x\in \Lambda, \\
M\in \Lambda, x\in V    &\Rightarrow (\lambda x. M) \in \Lambda,\\
M, N\in \Lambda         &\Rightarrow (MN) \in \Lambda, \\
M, N\in \Lambda, x\in V &\Rightarrow ((\lambda x. M)\,N) \in \Lambda.
\end{align*}
\end{definition}
\pause
\begin{minted}{cagda}
Name : Set
Name = String

data Expr : Set where
  var : Name â†’ Expr
  lam : Name â†’ Expr â†’ Expr
  _âˆ™_ : Expr â†’ Expr â†’ Expr
\end{minted}

\end{frame}

\section{Typed Lambda Calculus}
\begin{frame}{$\lambda\rightarrow$-Curry System}
\begin{definition}
\begin{itemize}
\item The set of types is noted with $ğ•‹ =\text{ Type}(\lambda\rightarrow)$.
$$ğ•‹ = ğ•\, |\, ğ”¹\, |\, ğ•‹ â†’ ğ•‹,$$
where $ğ• = \{Î±â‚,Î±â‚‚, \cdots \}$ be a set of type variables,
$ğ”¹$ stands for a collection of type constants for basic types
like \texttt{Nat} or \texttt{Bool}
\item A \emph{statement} is of the form $M : Ïƒ$ with $M âˆˆ Î›$ and $Ïƒ âˆˆ ğ•‹$
\item \emph{Derivation} inference rules
\vskip 1mm
\begin{columns}
  \begin{column}{0.5\textwidth}
    \begin{prooftree}
    \AxiomC{$M : Ïƒ âŸ¶ Ï„$}
    \AxiomC{$N : Ïƒ$}
    \BinaryInfC{$MN : Ï„$}
    \end{prooftree}
  \end{column}
  \begin{column}{0.5\textwidth}
    \begin{prooftree}
    \AxiomC{$[x : \sigma]^{(1)}$}
    \UnaryInfC{$\vdots$}
    \UnaryInfC{$M : \tau$}
    \RightLabel{\scriptsize (1)}
    \UnaryInfC{$Î»x.M : Ïƒ â†’ \tau$}
    \end{prooftree}
  \end{column}
\end{columns}
\item A statement $M : \sigma$ is derivable form a \textit{basis} $Î“$ denoted by $Î“ âŠ¢ M : Ïƒ$
where basis stands for be a set of statements with only distinct (term) variables as subjects
\end{itemize}
\end{definition}
\end{frame}


\section{Syntax Definitions}
\begin{frame}[fragile]{Syntax defintion based on ~\citep{cactus}, and \citep{nad}}
\begin{itemize}
  \item Typing syntax: $ğ•‹ = ğ•\, |\, ğ”¹\, |\, ğ•‹ â†’ ğ•‹,$
  \pause
  \vskip 1.5mm
\begin{minted}{cagda}
module Typing (U : Set) where

data Type : Set where
  base : U    â†’ Type
  _âŸ¶_  : Type â†’ Type â†’ Type
\end{minted}
\pause
\item $\lambda\rightarrow$-Curry Syntax
\vskip 1.5mm
\begin{minted}{cagda}
module Syntax (Type : Set) where

open import Data.String

Name : Set
Name = String

-- Statements.
data Formal : Set where
  _âˆ¶_ : Name â†’ Type â†’ Formal

data Expr : Set where
  var : Name   â†’ Expr
  lam : Formal â†’ Expr â†’ Expr
  _âˆ™_ : Expr   â†’ Expr â†’ Expr
\end{minted}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{\texttt{module Examples (Type : Set) where}}
\begin{minted}{cagda}
open import Syntax Type

postulate
  A : Type

x = var "x"
y = var "y"
z = var "z"

-- I, K, S : Expr

I = lam ("x" âˆ¶ A) x                  -- Î»x.x, x âˆˆ A
K = lam ("x" âˆ¶ A) (lam ("y" âˆ¶ A) x)  -- Î»xy.x, x,y âˆˆ A
S =
  lam ("x" âˆ¶ A)
    (lam ("y" âˆ¶ A)
      (lam ("z" âˆ¶ A)
        ((x âˆ™ z) âˆ™ (y âˆ™ z))))        -- Î»xyz.xz(yz), x,y,z âˆˆ A
\end{minted}
\end{frame}

\section{Decibility of Type Assignment}
\begin{frame}{Decibility of Type Assignment~\citep{barendregt2013lambda}}
% \begin{equation*}
% Î“ âŠ¢ M : Ï„
% \end{equation*}
\begin{tabular}{ll}
{\color{blu} \textbf{Problem}} & {\color{blu} \textbf{Question}} \\
{\color{blu} Typability}       & Given $M$ does exists a $Ïƒ$, $Î“âŠ¢ M : Ïƒ$? \\
{\color{blu} Type-checking}    & Given $M$ and $Ï„$, $Î“âŠ¢ M : Ï„$?  \\
{\color{blu} Inhabitation}     & Given $Ï„$, does exists an $M$ such that $Î“âŠ¢ M : Ïƒ$?\\
\end{tabular}
\pause
\begin{theorem}%[Typability]
\begin{itemize}
\item It is decidable whether a term is typable in $\lambda\rightarrow$.
\item If a term $M$ is typable in $\lambda\rightarrow$, then M has a principal type scheme, i.e.
a type $Ïƒ$ such that every possible type for $M$ is a subsitution instance of $Ïƒ$.
Moreover $Ïƒ$ is computable from $M$.
\end{itemize}
\end{theorem}

\begin{theorem}%[Type-checking]
Type checking for $\lambda\rightarrow$ is decidable.
\end{theorem}

\end{frame}

\section{Well-Scoped Lambda Expressions}
\begin{frame}{De Bruijn Index}
\begin{itemize}
\item The indexes are natural numbers that represent the occurrences of the variable in a Î»-term
$$  Î»x. Î»y. x â‡  Î» Î» 2$$
\item The natural number denotes the number of binders that are in scope between that occurrence and its corresponding binder
$$Î»x. Î»y. Î»z. x z (y z)  â‡ Î» Î» Î» 3 1 (2 1)$$
\item Check for $Î±$-equivalence is the same as that for syntactic equality
\end{itemize}
\end{frame}

\begin{frame}[fragile]{module Bound (Type : Set) where}
% Well-scoped Expresions with respect to a variable Binder.
\begin{minted}{cagda}
data Expr (n : â„•) : Set where
  var : Fin n  â†’ Expr n
  lam : Type   â†’ Expr (suc n) â†’ Expr n
  _âˆ™_ : Expr n â†’ Expr n       â†’ Expr n

Binder : â„• â†’ Set
Binder = Vec Name

data _âŠ¢_â‡_ : âˆ€ {n} â†’ Binder n â†’ S.Expr â†’ Expr n â†’ Set where
  var-zero : âˆ€ {n x} {Î“ : Binder n}
           â†’ Î“ , x âŠ¢ var x â‡ var (# 0)

  var-suc  : âˆ€ {n x y k} {Î“ : Binder n} {p : False (x â‰Ÿ y)}
           â†’ Î“ âŠ¢ var x â‡ var k
           â†’ Î“ , y âŠ¢ var x â‡ var (suc k)

  lam      : âˆ€ {n x Ï„ t tâ€²} {Î“ : Binder n}
           â†’ Î“ , x âŠ¢ t â‡ tâ€²
           â†’ Î“ âŠ¢ lam (x âˆ¶ Ï„) t â‡ lam Ï„ tâ€²

  _âˆ™_      : âˆ€ {n tâ‚ tâ‚â€² tâ‚‚ tâ‚‚â€²} {Î“ : Binder n}
           â†’ Î“ âŠ¢ tâ‚ â‡ tâ‚â€²
           â†’ Î“ âŠ¢ tâ‚‚ â‡ tâ‚‚â€²
           â†’ Î“ âŠ¢ tâ‚ âˆ™ tâ‚‚ â‡ tâ‚â€² âˆ™ tâ‚‚â€²
\end{minted}
\end{frame}

\begin{frame}[fragile]{Examples}
\begin{minted}{cagda}
âˆ… : Binder 0
âˆ… = []

Î“ : Binder 2
Î“ = "x" âˆ· "y" âˆ· []

e1 : "x" âˆ· "y" âˆ· [] âŠ¢ var "x" â‡ var (# 0)
e1 = var-zero

I : [] âŠ¢ lam ("x" âˆ¶ A) (var "x")
       â‡ lam A (var (# 0))
I = lam var-zero

K : [] âŠ¢ lam ("x" âˆ¶ A) (lam ("y" âˆ¶ A) (var "x"))
       â‡ lam A (lam A (var (# 1)))
K = lam (lam (var-suc var-zero))

Kâ‚‚ : [] âŠ¢ lam ("x" âˆ¶ A) (lam ("y" âˆ¶ A) (var "y"))
        â‡ lam A (lam A (var (# 0)))
Kâ‚‚ = lam (lam var-zero)

P : Î“ âŠ¢ lam ("x" âˆ¶ A) (lam ("y" âˆ¶ A) (lam ("z" âˆ¶ A) (var "x")))
      â‡ lam A (lam A (lam A (var (# 2))))
P = {!!}
\end{minted}
\end{frame}


\begin{frame}[fragile]{Scope-checking}
\begin{minted}{cagda}
name-dec : âˆ€ {n} {Î“ : Binder n} {x y : Name} {t : Expr (suc n)}
         â†’ Î“ , y âŠ¢ var x â‡ t
         â†’ x â‰¡ y âŠ âˆƒ[ tâ€² ] (Î“ âŠ¢ var x â‡ tâ€²)

âŠ¢subst : âˆ€ {n} {x y} {Î“ : Binder n} {t}
       â†’ x â‰¡ y
       â†’ Î“ , x âŠ¢ var x â‡ t
       â†’ Î“ , y âŠ¢ var x â‡ t

find-name : âˆ€ {n}
          â†’ (Î“ : Binder n)
          â†’ (x : Name)
          â†’ Dec (âˆƒ[ t ] (Î“ âŠ¢ var x â‡ t))

check : âˆ€ {n}
      â†’ (Î“ : Binder n)
      â†’ (t : S.Expr)
      â†’ Dec (âˆƒ[ tâ€² ] (Î“ âŠ¢ t â‡ tâ€²))

scope : (t : S.Expr) â†’ {p : True (check [] t)} â†’ Expr 0
scope t {p} = projâ‚ (toWitness p)
\end{minted}
\end{frame}

\begin{frame}[fragile]
\begin{minted}{cagda}
postulate A : Type

Iâ‚ : S.Expr
Iâ‚ = S.lam ("x" âˆ¶ A) (S.var "x")

open import Data.Unit

I : Expr 0
I = scope Iâ‚ {p = âŠ¤.tt}  -- Use C-C-C-n.

x, y, z : S.Expr

x = var "x"
y = var "y"
z = var "z"

Sâ‚ : S.Expr
Sâ‚ =
  lam ("x" âˆ¶ A)
    (lam ("y" âˆ¶ A)
    (lam ("z" âˆ¶ A)
    ((x âˆ™ z) âˆ™ (y âˆ™ z))))

S : Expr 0
S = scope Sâ‚ {p = âŠ¤.tt}
\end{minted}
\end{frame}


\begin{frame}{Typing Rules}
\begin{itemize}
\item Introduction\\
\begin{prooftree}
\AxiomC{$Î“(t) = \tau$}
\UnaryInfC{$Î“ âŠ¢ t : \tau$}
\end{prooftree}\hfill

\item Abstraction\\
\begin{prooftree}
\AxiomC{$Î“ , Ï„ âŠ¢ t : Ï„'$}
\UnaryInfC{$Î“ âŠ¢ Î»(x :Ï„). t âˆ¶ Ï„ âŸ¶ Ï„â€²$}
\end{prooftree}\hfill

\item Application
\begin{prooftree}
\AxiomC{$Î“ âŠ¢ tâ‚ : Ï„ âŸ¶ Ï„â€²$}
\AxiomC{$Î“ âŠ¢ tâ‚‚ : Ï„$}
\BinaryInfC{$Î“ âŠ¢ tâ‚âˆ™ tâ‚‚ âˆ¶ Ï„â€²$}
\end{prooftree}\hfill
\end{itemize}

\end{frame}

\section{Typability and Type-checking}
\begin{frame}[fragile]{\texttt{module Typing (U : Set) where}}
\begin{minted}{cagda}
open import Bound Type hiding (_,_)

Ctxt : â„• â†’ Set
Ctxt = Vec Type

_,_ : âˆ€ {n} â†’ Ctxt n â†’ Type â†’ Ctxt (suc n)
Î“ , x = x âˆ· Î“

data _âŠ¢_âˆ¶_ : âˆ€ {n} â†’ Ctxt n â†’ Expr n â†’ Type â†’ Set where
  tVar : âˆ€ {n Î“} {x : Fin n}
       â†’ Î“ âŠ¢ var x âˆ¶ lookup x Î“

  tLam : âˆ€ {n} {Î“ : Ctxt n} {t} {Ï„ Ï„â€²}
       â†’ Î“ , Ï„ âŠ¢ t âˆ¶ Ï„â€²
       â†’ Î“ âŠ¢ lam Ï„ t âˆ¶ Ï„ âŸ¶ Ï„â€²

  _âˆ™_  : âˆ€ {n} {Î“ : Ctxt n} {tâ‚ tâ‚‚} {Ï„ Ï„â€²}
       â†’ Î“ âŠ¢ tâ‚ âˆ¶ Ï„ âŸ¶ Ï„â€²
       â†’ Î“ âŠ¢ tâ‚‚ âˆ¶ Ï„
       â†’ Î“ âŠ¢ tâ‚ âˆ™ tâ‚‚ âˆ¶ Ï„â€²
\end{minted}
\end{frame}

\begin{frame}[fragile]
\begin{minted}{cagda}

postulate
  Bool : Type

ex : [] , Bool âŠ¢ var (# 0) âˆ¶ Bool
ex = tVar

ex2 : [] âŠ¢ lam Bool (var (# 0)) âˆ¶ Bool âŸ¶ Bool
ex2 = tLam tVar

postulate
  Word : Type
  Num  : Type

K : [] âŠ¢ lam Word (lam Num (var (# 1))) âˆ¶ Word âŸ¶ Num âŸ¶ Word
K = tLam (tLam tVar)
\end{minted}
\end{frame}

% \begin{frame}[allowframebreaks]{References}
% \printbibliography
% \end{frame}


\end{document}